// algorithmExploitationEngine.js
// Clean implementation of helpers for generating hooks, engagement bait, captions,
// timing recommendations, pacing and an overall optimization function.

const { generateCustomHashtags } = require('./hashtagEngine');
const crypto = require('crypto');
let db = null;
try { db = require('../firebaseAdmin').db; } catch (e) { /* optional */ }

// Simple, ASCII-only templates to avoid encoding/parser issues in CI
const HOOK_TEMPLATES = {
  question: [
    'Did you know {topic}?',
    'What if I told you {topic}?',
    'Can you believe {topic}?',
    'Why does {topic}?',
    'How to {topic} in 60 seconds'
  ],
  curiosity: [
    'The secret to {topic} revealed',
    'What happens when you {topic}',
    'Nobody expected this {topic} result',
    'This {topic} will blow your mind'
  ],
  urgency: [
    'You need to see this before {topic}',
    'This {topic} trick changes everything',
    'Dont scroll past this {topic}',
    'Last chance to {topic}'
  ],
  entertainment: [
    'Wait for it...',
    'You will not believe this!',
    'This is insane!',
    'Watch till the end!'
  ]
};

const ENGAGEMENT_PATTERNS = {
  comment: ["Comment '{word}' if you agree", 'Drop an emoji in the comments', 'Tell me your {topic} story below', 'Which one are you? Comment below', 'Tag someone who needs to see this'],
  share: ['Share this with someone who {action}', 'Send this to your {person}', 'Repost if you {feeling}', 'Share to save for later', 'Tag 3 friends who need this'],
  follow: ['Follow for more {topic} content', 'Follow if you want to see part 2', 'Hit follow for daily {topic} tips', 'Follow for the full tutorial', 'Dont miss part 2 - follow now'],
  like: ['Double tap if you {feeling}', 'Like if this helped you', 'Heart this if you agree', 'Smash that like button', 'Show some love if you enjoyed this']
};

const TRENDING_SOUNDS = {
  tiktok: [ { id: 'sound_001', name: 'Viral Dance Beat', category: 'dance', popularity: 95 }, { id: 'sound_002', name: 'Trending Audio Meme', category: 'comedy', popularity: 92 } ],
  instagram: [ { id: 'audio_001', name: 'Reels Trending Audio', category: 'general', popularity: 93 } ],
  youtube: [ { id: 'music_001', name: 'Copyright-Free Beat', category: 'general', popularity: 85 } ]
  ,
  linkedin: [],
  reddit: []
};

const CAPTION_TIMING = {
  tiktok: { hook: { start: 0, end: 3, position: 'center' }, main: { start: 3, end: 15, position: 'bottom' }, cta: { start: 15, end: 30, position: 'center' } },
  instagram: { hook: { start: 0, end: 3, position: 'center' }, main: { start: 3, end: 20, position: 'bottom' }, cta: { start: 20, end: 30, position: 'center' } },
  youtube: { hook: { start: 0, end: 8, position: 'center' }, main: { start: 8, end: 120, position: 'bottom-left' }, cta: { start: 120, end: 180, position: 'center' } }
};

const PACING_RULES = {
  tiktok: { optimalLength: 21, cutFrequency: 2, patternInterrupts: 3, textOverlays: true, transitions: 'fast' },
  instagram: { optimalLength: 30, cutFrequency: 3, patternInterrupts: 2, textOverlays: true, transitions: 'medium' },
  youtube: { optimalLength: 180, cutFrequency: 5, patternInterrupts: 5, textOverlays: true, transitions: 'varied' }
};

function generateHook(content = {}, platform = 'tiktok') {
  const category = content.category || 'entertainment';
  const templates = HOOK_TEMPLATES[category] || HOOK_TEMPLATES.entertainment;
  let template = templates[crypto.randomInt(0, templates.length)];
  const topic = content.title || content.category || 'this';
  template = template.replace('{topic}', topic);
  template = template.replace('{emotion}', ['inspiring', 'shocking', 'heartwarming', 'unbelievable'][crypto.randomInt(0, 4)]);
  template = template.replace('{number}', [5, 10, 100, 1000][crypto.randomInt(0, 4)]);
  if ((platform === 'tiktok' || platform === 'youtube_shorts') && content.title && content.title.length < 50) return content.title + ' - ' + template;
  return template;
}

function generateEngagementBait(content = {}, platform = 'tiktok') {
  let engagementTypes;
  if (platform === 'tiktok') engagementTypes = ['comment', 'share', 'follow'];
  else if (platform === 'youtube' || platform === 'youtube_shorts') engagementTypes = ['comment', 'like', 'follow'];
  else if (platform === 'twitter') engagementTypes = ['comment', 'share'];
  else engagementTypes = ['comment', 'like'];
  // Add platform-specific nuance for LinkedIn/Reddit
  if (platform === 'linkedin') engagementTypes = ['share', 'comment', 'follow'];
  if (platform === 'reddit') engagementTypes = ['comment', 'upvote', 'share'];
  const selectedType = engagementTypes[crypto.randomInt(0, engagementTypes.length)];
  const templates = ENGAGEMENT_PATTERNS[selectedType] || ENGAGEMENT_PATTERNS.comment;
  let template = templates[crypto.randomInt(0, templates.length)];
  template = template.replace('{word}', ['YES', 'FACTS', 'REAL', 'TRUE'][crypto.randomInt(0, 4)]);
  template = template.replace('{emoji}', '');
  template = template.replace('{topic}', content.category || 'this');
  template = template.replace('{action}', ['needs this', 'loves this', 'should see this'][crypto.randomInt(0, 3)]);
  template = template.replace('{person}', ['best friend', 'squad', 'family', 'followers'][crypto.randomInt(0, 4)]);
  template = template.replace('{feeling}', ['relate', 'agree', 'love this', 'needed this'][crypto.randomInt(0, 4)]);
  return template;
}

function optimizeCaption(content = {}, platform = 'tiktok') {
  const caption = content.description || content.title || '';
  const rules = {
    tiktok: { maxLength: 150, emojiDensity: 'high', hashtagCount: 5 },
    instagram: { maxLength: 2200, emojiDensity: 'medium', hashtagCount: 10 },
    youtube: { maxLength: 5000, emojiDensity: 'low', hashtagCount: 3 },
    linkedin: { maxLength: 1300, emojiDensity: 'low', hashtagCount: 5 },
    reddit: { maxLength: 40000, emojiDensity: 'low', hashtagCount: 0 },
    youtube_shorts: { maxLength: 100, emojiDensity: 'high', hashtagCount: 5 },
    twitter: { maxLength: 280, emojiDensity: 'medium', hashtagCount: 3 },
    facebook: { maxLength: 63206, emojiDensity: 'low', hashtagCount: 5 }
  };
  const platformRules = rules[platform] || rules.twitter;
  let out = caption;
  if (out.length > platformRules.maxLength) out = out.substring(0, platformRules.maxLength - 3) + '...';
  return { caption: out, maxLength: platformRules.maxLength, recommendedHashtagCount: platformRules.hashtagCount };
}

function calculateOptimalPostingTime(platform, userTimezone = 'UTC') {
  const peakTimes = {
    tiktok: [ { hour: 14, day: [1,2,3,4,5] }, { hour: 18, day: [1,2,3,4,5] }, { hour: 11, day: [0,6] } ],
    instagram: [ { hour: 11, day: [1,2,3,4,5] }, { hour: 14, day: [1,2,3,4,5] }, { hour: 19, day: [0,6] } ],
    youtube: [ { hour: 14, day: [1,2,3,4,5] }, { hour: 20, day: [0,6] } ],
    youtube_shorts: [ { hour: 15, day: [1,2,3,4,5] }, { hour: 21, day: [0,6] } ],
    twitter: [ { hour: 9, day: [1,2,3,4,5] }, { hour: 12, day: [1,2,3,4,5] }, { hour: 17, day: [1,2,3,4,5] } ],
    facebook: [ { hour: 13, day: [1,2,3,4,5] }, { hour: 15, day: [1,2,3,4,5] } ]
  };
  const platformPeakTimes = peakTimes[platform] || peakTimes.twitter;
  const now = new Date();
  const currentDay = now.getDay();
  const nextOptimalTimes = platformPeakTimes.filter(t => t.day.includes(currentDay)).map(t => {
    const d = new Date(now);
    d.setUTCHours(t.hour, 0, 0, 0);
    if (d < now) d.setDate(d.getDate() + 7);
    return d;
  }).sort((a,b) => a - b);
  return { nextOptimalTime: nextOptimalTimes[0] || new Date(now.getTime() + 24*60*60*1000), allOptimalTimes: nextOptimalTimes, recommendation: nextOptimalTimes[0] ? 'Best time to post: ' + nextOptimalTimes[0].toLocaleString() : 'No recommendation' };
}

function optimizeContentFormat(content = {}, platform = 'tiktok') {
  const { type, duration, aspectRatio } = content;
  const formatRules = {
    tiktok: { videoLength: { min: 15, max: 60, optimal: 30 }, aspectRatio: '9:16' },
    instagram: { videoLength: { min: 3, max: 60, optimal: 30 }, aspectRatio: '9:16' },
    youtube_shorts: { videoLength: { min: 15, max: 60, optimal: 45 }, aspectRatio: '9:16' },
    youtube: { videoLength: { min: 60, max: 600, optimal: 480 }, aspectRatio: '16:9' },
    twitter: { videoLength: { min: 5, max: 140, optimal: 45 }, aspectRatio: '16:9' }
  };
  const rules = formatRules[platform] || formatRules.twitter;
  const recommendations = [];
  if (type === 'video' && duration) {
    if (duration < rules.videoLength.min) recommendations.push('Video too short. Minimum: ' + rules.videoLength.min + 's');
    else if (duration > rules.videoLength.max) recommendations.push('Video too long. Maximum: ' + rules.videoLength.max + 's');
    else if (Math.abs(duration - rules.videoLength.optimal) > 15) recommendations.push('Optimal length: ' + rules.videoLength.optimal + 's (current: ' + duration + 's)');
  }
  if (aspectRatio && aspectRatio !== rules.aspectRatio) recommendations.push('Recommended aspect ratio: ' + rules.aspectRatio + ' (current: ' + aspectRatio + ')');
  return { rules, recommendations, isOptimal: recommendations.length === 0 };
}

function calculateOptimizationScore(optimizedContent = {}) {
  let score = 0; const maxScore = 100;
  if (optimizedContent.hook) score += 20;
  if (optimizedContent.engagementBait) score += 20;
  if (optimizedContent.optimizedCaption) score += 15;
  if (optimizedContent.hashtags && optimizedContent.hashtags.length > 0) score += 15;
  if (optimizedContent.optimalTiming) score += 10;
  if (optimizedContent.formatOptimization && optimizedContent.formatOptimization.isOptimal) score += 20; else if (optimizedContent.formatOptimization) score += 10;
  return { score, maxScore, percentage: Math.round((score / maxScore) * 100), grade: score >= 80 ? 'A' : score >= 60 ? 'B' : score >= 40 ? 'C' : 'D' };
}

async function optimizeForAlgorithm(content = {}, platform = 'tiktok', options = {}) {
  const { generateHooks = true, generateEngagement = true, optimizeCaptions = true, calculateTiming = true, generateHashtags = true, formatCheck = true } = options;
  const optimizations = { ...content, platform, optimized: true, optimizationTimestamp: new Date().toISOString() };
  if (generateHooks) optimizations.hook = generateHook(content, platform);
  if (generateEngagement) optimizations.engagementBait = generateEngagementBait(content, platform);
  if (optimizeCaptions) { const cap = optimizeCaption(content, platform); optimizations.optimizedCaption = cap.caption; optimizations.captionMetadata = { maxLength: cap.maxLength, recommendedHashtagCount: cap.recommendedHashtagCount }; }
  if (calculateTiming) optimizations.optimalTiming = calculateOptimalPostingTime(platform);
  if (generateHashtags) { try { optimizations.hashtags = await generateCustomHashtags({ content, platform, nicheTags: content.tags || [] }); } catch (e) { optimizations.hashtags = []; } }
  if (formatCheck) optimizations.formatOptimization = optimizeContentFormat(content, platform);
  optimizations.optimizationScore = calculateOptimizationScore(optimizations);
  return optimizations;
}

function matchTrendingSound(content = {}, platform = 'tiktok') {
  const sounds = TRENDING_SOUNDS[platform] || TRENDING_SOUNDS.tiktok;
  const category = content.category || 'general';
  let matchingSounds = sounds.filter(s => s.category === category);
  if (!matchingSounds.length) matchingSounds = sounds;
  matchingSounds.sort((a,b) => b.popularity - a.popularity);
  const selected = matchingSounds[0] || sounds[0];
  return { soundId: selected.id, soundName: selected.name, category: selected.category, popularity: selected.popularity, platform, recommendation: 'Use this trending sound for maximum reach' };
}

function optimizeCaptionTiming(platform, videoDuration) {
  const timing = CAPTION_TIMING[platform] || CAPTION_TIMING.tiktok;
  const recommendations = [];
  recommendations.push({ type: 'hook', text: 'Attention grabber', startTime: timing.hook.start, endTime: Math.min(timing.hook.end, videoDuration), position: timing.hook.position, priority: 'critical' });
  if (videoDuration > timing.main.start) recommendations.push({ type: 'main', text: 'Main content text', startTime: timing.main.start, endTime: Math.min(timing.main.end, videoDuration), position: timing.main.position, priority: 'high' });
  if (videoDuration > timing.cta.start) recommendations.push({ type: 'cta', text: 'Call to action', startTime: timing.cta.start, endTime: Math.min(timing.cta.end, videoDuration), position: timing.cta.position, priority: 'medium' });
  return { platform, videoDuration, recommendations, totalOverlays: recommendations.length };
}

function optimizeLengthAndPacing(content = {}, platform = 'tiktok') {
  const rules = PACING_RULES[platform] || PACING_RULES.tiktok;
  const currentLength = content.duration || 30;
  const recommendations = [];
  if (currentLength !== rules.optimalLength) recommendations.push({ type: 'length', current: currentLength, optimal: rules.optimalLength, message: 'Adjust video length to ' + rules.optimalLength + ' seconds', impact: 'high' });
  const recommendedCuts = Math.floor(currentLength / rules.cutFrequency);
  recommendations.push({ type: 'cuts', recommended: recommendedCuts, frequency: rules.cutFrequency, message: 'Add ' + recommendedCuts + ' cuts', impact: 'high' });
  recommendations.push({ type: 'pattern_interrupts', recommended: rules.patternInterrupts, message: 'Include pattern interrupts', impact: 'medium' });
  if (rules.textOverlays) recommendations.push({ type: 'text_overlays', message: 'Add text overlays', impact: 'medium' });
  recommendations.push({ type: 'transitions', style: rules.transitions, message: 'Use ' + rules.transitions + ' transitions', impact: 'low' });
  return { platform, currentLength, optimalLength: rules.optimalLength, recommendations, pacingScore: calculatePacingScore(currentLength, rules) };
}

function calculatePacingScore(currentLength, rules) { const lengthDiff = Math.abs(currentLength - rules.optimalLength); const lengthScore = Math.max(0, 100 - (lengthDiff * 2)); return Math.round(lengthScore); }

function generateOptimizationRecommendations(score, pacing) {
  const recommendations = [];
  if (score < 70) recommendations.push({ priority: 'high', message: 'Content needs significant optimization', actions: ['Add compelling hook', 'Use trending sound', 'Optimize video length'] });
  else if (score < 85) recommendations.push({ priority: 'medium', message: 'Content is good but can be improved', actions: ['Fine-tune pacing', 'Add more engagement bait', 'Optimize caption timing'] });
  else recommendations.push({ priority: 'low', message: 'Content is well-optimized', actions: ['Monitor performance', 'Test variations', 'Scale promotion'] });
  if (pacing && pacing.recommendations) pacing.recommendations.forEach(rec => { if (rec.impact === 'high') recommendations.push({ priority: 'high', message: rec.message, type: rec.type }); });
  return recommendations;
}

async function saveOptimizationData(optimizationData = {}) { if (!db) return { success: false, error: 'DB not available' }; try { const optRef = db.collection('algorithm_optimizations').doc(); await optRef.set({ ...optimizationData, id: optRef.id, createdAt: new Date().toISOString() }); return { success: true, optimizationId: optRef.id }; } catch (e) { return { success: false, error: e.message }; } }

module.exports = {
  optimizeForAlgorithm,
  generateHook,
  generateEngagementBait,
  optimizeCaption,
  calculateOptimalPostingTime,
  optimizeContentFormat,
  calculateOptimizationScore,
  matchTrendingSound,
  optimizeCaptionTiming,
  optimizeLengthAndPacing,
  saveOptimizationData,
  generateOptimizationRecommendations,
  HOOK_TEMPLATES,
  ENGAGEMENT_PATTERNS,
  TRENDING_SOUNDS,
  CAPTION_TIMING,
  PACING_RULES
};
