// algorithmExploitationEngine.js
// AutoPromote Algorithmic Exploitation Logic
<<<<<<< Updated upstream
// Maximizes algorithmic favor with hooks, trending sounds, engagement bait, optimal timing

const { generateCustomHashtags } = require('./hashtagEngine');

// ============================================
// 1. HOOK GENERATOR
// ============================================
const HOOK_TEMPLATES = {
  question: [
    "Did you know {topic}?",
    "What if I told you {topic}?",
    "Can you believe {topic}?",
    "Why does {topic}?",
    "How to {topic} in 60 seconds"
  ],
  controversy: [
    "Everyone is wrong about {topic}",
    "The truth about {topic} nobody tells you",
    "Stop doing {topic} - here's why",
    "{topic} is a lie - here's proof",
    "I tried {topic} for 30 days - shocking results"
  ],
  urgency: [
    "You need to see this before {topic}",
    "This {topic} trick changes everything",
    "Don't scroll past this {topic}",
    "Last chance to {topic}",
    "Only {number} people know this {topic} secret"
  ],
  curiosity: [
    "The secret to {topic} revealed",
    "What happens when you {topic}",
    "Nobody expected this {topic} result",
    "This {topic} will blow your mind",
    "Watch what happens when {topic}"
  ],
  emotional: [
    "This {topic} made me cry",
    "You won't believe this {topic} story",
    "The most {emotion} {topic} ever",
    "This {topic} will change your life",
    "I can't stop thinking about {topic}"
  ]
};

function generateHook(content, platform) {
  const { title, description, category, type } = content;
  const topic = title || category || 'this';
  
  // Select hook type based on platform
  let hookType;
  if (platform === 'tiktok' || platform === 'youtube_shorts') {
    hookType = Math.random() > 0.5 ? 'curiosity' : 'urgency';
  } else if (platform === 'twitter') {
    hookType = Math.random() > 0.5 ? 'question' : 'controversy';
  } else if (platform === 'youtube') {
    hookType = 'curiosity';
  } else {
    hookType = 'question';
  }
  
  const templates = HOOK_TEMPLATES[hookType];
  const template = templates[Math.floor(Math.random() * templates.length)];
  
  // Replace placeholders
  const hook = template
    .replace('{topic}', topic)
    .replace('{emotion}', ['inspiring', 'shocking', 'heartwarming', 'unbelievable'][Math.floor(Math.random() * 4)])
    .replace('{number}', [5, 10, 100, 1000][Math.floor(Math.random() * 4)]);
=======
// Maximizes algorithmic favor with hooks, trending sounds, engagement bait, and advanced manipulation

const { db } = require('../firebaseAdmin');

// Hook templates by category (3-second rule)
const HOOK_TEMPLATES = {
  entertainment: [
    'Wait for it... 😱',
    'You won\'t believe this! 🤯',
    'This is insane! 🔥',
    'Watch till the end! 👀',
    'I can\'t believe this happened! 😲',
    'This will blow your mind! 💥',
    'Stop scrolling! ⚠️',
    'This is crazy! 🤪'
  ],
  education: [
    'Here\'s the secret: 🔑',
    'Nobody tells you this: 🤫',
    'Learn this in 60 seconds: ⏱️',
    'This changed everything: ✨',
    'The truth about {topic}: 💡',
    'What they don\'t teach you: 📚',
    'This will save you hours: ⏰',
    'The hack nobody knows: 🎯'
  ],
  lifestyle: [
    'Life-changing tip! 🌟',
    'You need to try this! ✅',
    'This transformed my life! 🦋',
    'Game changer alert! 🚨',
    'Best decision ever! 💯',
    'This is a must-try! 🎁',
    'Your life will change! 🌈',
    'Don\'t skip this! ⭐'
  ],
  fitness: [
    'Transform in 30 days! 💪',
    'Get results fast! ⚡',
    'This workout is insane! 🔥',
    'Feel the burn! 🏋️',
    'No equipment needed! 🎯',
    'Get fit at home! 🏠',
    'Burn calories fast! 🔥',
    'Build muscle quick! 💪'
  ],
  food: [
    'This recipe is amazing! 🍳',
    'So easy to make! 👨‍🍳',
    'Tastes incredible! 😋',
    'Better than restaurant! 🍽️',
    'You have to try this! 🤤',
    'Secret ingredient revealed! 🤫',
    'Perfect every time! ✨',
    '5-minute recipe! ⏱️'
  ],
  business: [
    'Make money online! 💰',
    'Grow your business! 📈',
    'Scale to 6 figures! 💵',
    'Business hack revealed! 🎯',
    'Entrepreneur secret! 🔑',
    'Passive income tip! 💸',
    'Double your revenue! 📊',
    'This changed my business! 🚀'
  ],
  tech: [
    'This is revolutionary! 🚀',
    'Tech game changer! 💻',
    'You need this! 📱',
    'Mind-blowing tech! 🤯',
    'Future is here! ⚡',
    'This will change everything! 🌐',
    'Innovation alert! 💡',
    'Next-level tech! 🎮'
  ]
};

// Engagement bait templates
const ENGAGEMENT_BAIT = {
  questions: [
    'What do you think? 🤔',
    'Comment your answer! 💬',
    'Which one would you choose? 🎯',
    'Have you tried this? 👇',
    'What\'s your experience? 📝',
    'Drop a 🔥 if you agree!',
    'Tag someone who needs this! 👥',
    'Share your story below! 📖'
  ],
  controversy: [
    'Unpopular opinion: {statement}',
    'Hot take: {statement}',
    'Change my mind: {statement}',
    'This is controversial but...',
    'Nobody talks about this...',
    'The truth nobody wants to hear...',
    'I\'m going to say it...',
    'This might be unpopular but...'
  ],
  challenges: [
    'Can you do this? 💪',
    'Try this challenge! 🎯',
    'Bet you can\'t! 😏',
    'Who can relate? 🙋',
    'Show me your version! 📸',
    'Duet this! 🎵',
    'Stitch your reaction! 🎬',
    'Join the challenge! 🏆'
  ],
  cta: [
    'Follow for more! 🔔',
    'Save this for later! 📌',
    'Share with friends! 🔄',
    'Like if you agree! ❤️',
    'Subscribe now! ✅',
    'Turn on notifications! 🔔',
    'Check link in bio! 🔗',
    'Watch part 2! ▶️'
  ]
};

// Trending sounds database (mock - integrate with real APIs)
const TRENDING_SOUNDS = {
  tiktok: [
    { id: 'sound_001', name: 'Viral Dance Beat', category: 'dance', popularity: 95 },
    { id: 'sound_002', name: 'Trending Audio Meme', category: 'comedy', popularity: 92 },
    { id: 'sound_003', name: 'Emotional Piano', category: 'lifestyle', popularity: 88 },
    { id: 'sound_004', name: 'Upbeat Pop', category: 'entertainment', popularity: 90 },
    { id: 'sound_005', name: 'Motivational Speech', category: 'motivation', popularity: 85 }
  ],
  instagram: [
    { id: 'audio_001', name: 'Reels Trending Audio', category: 'general', popularity: 93 },
    { id: 'audio_002', name: 'Viral Song Snippet', category: 'music', popularity: 91 },
    { id: 'audio_003', name: 'Comedy Sound Effect', category: 'comedy', popularity: 87 },
    { id: 'audio_004', name: 'Aesthetic Music', category: 'lifestyle', popularity: 89 }
  ],
  youtube: [
    { id: 'music_001', name: 'Copyright-Free Beat', category: 'general', popularity: 85 },
    { id: 'music_002', name: 'Vlog Background Music', category: 'vlog', popularity: 82 },
    { id: 'music_003', name: 'Energetic Intro', category: 'entertainment', popularity: 88 }
  ]
};

// Caption timing optimization (when to post text overlays)
const CAPTION_TIMING = {
  tiktok: {
    hook: { start: 0, end: 3, position: 'center' },
    main: { start: 3, end: 15, position: 'bottom' },
    cta: { start: 15, end: 30, position: 'center' }
  },
  instagram: {
    hook: { start: 0, end: 3, position: 'center' },
    main: { start: 3, end: 20, position: 'bottom' },
    cta: { start: 20, end: 30, position: 'center' }
  },
  youtube: {
    hook: { start: 0, end: 8, position: 'center' },
    main: { start: 8, end: 120, position: 'bottom-left' },
    cta: { start: 120, end: 180, position: 'center' }
  }
};

// Video pacing optimization
const PACING_RULES = {
  tiktok: {
    optimalLength: 21, // seconds
    cutFrequency: 2, // seconds between cuts
    patternInterrupts: 3, // number of pattern interrupts
    textOverlays: true,
    transitions: 'fast'
  },
  instagram: {
    optimalLength: 30,
    cutFrequency: 3,
    patternInterrupts: 2,
    textOverlays: true,
    transitions: 'medium'
  },
  youtube: {
    optimalLength: 180,
    cutFrequency: 5,
    patternInterrupts: 5,
    textOverlays: true,
    transitions: 'varied'
  }
};

/**
 * Generate hook for content (3-second rule)
 * @param {object} content - Content object
 * @param {string} category - Content category
 * @returns {string} Generated hook
 */
function generateHook(content, category = 'entertainment') {
  const templates = HOOK_TEMPLATES[category] || HOOK_TEMPLATES.entertainment;
  let hook = templates[Math.floor(Math.random() * templates.length)];
  
  // Personalize with content title if available
  if (content.title && content.title.length < 50) {
    hook = content.title + ' ' + hook;
  }
  
  // Replace placeholders
  if (hook.includes('{topic}')) {
    const topic = content.category || 'this';
    hook = hook.replace('{topic}', topic);
  }
>>>>>>> Stashed changes
  
  return hook;
}

<<<<<<< Updated upstream
// ============================================
// 2. ENGAGEMENT BAIT GENERATOR
// ============================================
const ENGAGEMENT_PATTERNS = {
  comment: [
    "Comment '{word}' if you agree",
    "Drop a {emoji} in the comments",
    "Tell me your {topic} story below",
    "Which one are you? Comment below",
    "Tag someone who needs to see this"
  ],
  share: [
    "Share this with someone who {action}",
    "Send this to your {person}",
    "Repost if you {feeling}",
    "Share to save for later",
    "Tag 3 friends who need this"
  ],
  follow: [
    "Follow for more {topic} content",
    "Follow if you want to see part 2",
    "Hit follow for daily {topic} tips",
    "Follow for the full tutorial",
    "Don't miss part 2 - follow now"
  ],
  like: [
    "Double tap if you {feeling}",
    "Like if this helped you",
    "Heart this if you agree",
    "Smash that like button",
    "Show some love if you enjoyed this"
  ]
};

function generateEngagementBait(content, platform) {
  const { category, type } = content;
  
  // Select engagement type based on platform
  let engagementTypes;
  if (platform === 'tiktok') {
    engagementTypes = ['comment', 'share', 'follow'];
  } else if (platform === 'youtube' || platform === 'youtube_shorts') {
    engagementTypes = ['comment', 'like', 'follow'];
  } else if (platform === 'twitter') {
    engagementTypes = ['comment', 'share'];
  } else {
    engagementTypes = ['comment', 'like'];
  }
  
  const selectedType = engagementTypes[Math.floor(Math.random() * engagementTypes.length)];
  const templates = ENGAGEMENT_PATTERNS[selectedType];
  const template = templates[Math.floor(Math.random() * templates.length)];
  
  // Replace placeholders
  const bait = template
    .replace('{word}', ['YES', 'FACTS', 'REAL', 'TRUE'][Math.floor(Math.random() * 4)])
    .replace('{emoji}', ['🔥', '💯', '👇', '❤️', '🚀'][Math.floor(Math.random() * 5)])
    .replace('{topic}', category || 'this')
    .replace('{action}', ['needs this', 'loves this', 'should see this'][Math.floor(Math.random() * 3)])
    .replace('{person}', ['best friend', 'squad', 'family', 'followers'][Math.floor(Math.random() * 4)])
    .replace('{feeling}', ['relate', 'agree', 'love this', 'needed this'][Math.floor(Math.random() * 4)]);
  
  return bait;
}

// ============================================
// 3. CAPTION OPTIMIZER
// ============================================
function optimizeCaption(content, platform) {
  const { title, description, category } = content;
  let caption = description || title || '';
  
  // Platform-specific caption rules
  const rules = {
    tiktok: { maxLength: 150, emojiDensity: 'high', hashtagCount: 5 },
    instagram: { maxLength: 2200, emojiDensity: 'medium', hashtagCount: 10 },
    youtube: { maxLength: 5000, emojiDensity: 'low', hashtagCount: 3 },
    youtube_shorts: { maxLength: 100, emojiDensity: 'high', hashtagCount: 5 },
    twitter: { maxLength: 280, emojiDensity: 'medium', hashtagCount: 3 },
    facebook: { maxLength: 63206, emojiDensity: 'low', hashtagCount: 5 }
  };
  
  const platformRules = rules[platform] || rules.twitter;
  
  // Truncate if too long
  if (caption.length > platformRules.maxLength) {
    caption = caption.substring(0, platformRules.maxLength - 3) + '...';
  }
  
  // Add emojis based on density
  const emojis = ['🔥', '💯', '✨', '🚀', '💪', '👀', '🎯', '⚡'];
  if (platformRules.emojiDensity === 'high' && !caption.match(/[\u{1F300}-\u{1F9FF}]/u)) {
    caption = `${emojis[Math.floor(Math.random() * emojis.length)]} ${caption}`;
  }
  
  // Add line breaks for readability (except Twitter)
  if (platform !== 'twitter' && caption.length > 100) {
    caption = caption.replace(/\. /g, '.\n\n');
  }
  
  return {
    caption,
    maxLength: platformRules.maxLength,
    recommendedHashtagCount: platformRules.hashtagCount
  };
}

// ============================================
// 4. OPTIMAL POSTING TIME CALCULATOR
// ============================================
function calculateOptimalPostingTime(platform, userTimezone = 'UTC', audienceData = null) {
  // Peak engagement times by platform (in UTC)
  const peakTimes = {
    tiktok: [
      { hour: 14, day: [1, 2, 3, 4, 5] }, // 2 PM weekdays
      { hour: 18, day: [1, 2, 3, 4, 5] }, // 6 PM weekdays
      { hour: 11, day: [0, 6] }           // 11 AM weekends
    ],
    instagram: [
      { hour: 11, day: [1, 2, 3, 4, 5] }, // 11 AM weekdays
      { hour: 14, day: [1, 2, 3, 4, 5] }, // 2 PM weekdays
      { hour: 19, day: [0, 6] }           // 7 PM weekends
    ],
    youtube: [
      { hour: 14, day: [1, 2, 3, 4, 5] }, // 2 PM weekdays
      { hour: 20, day: [0, 6] }           // 8 PM weekends
    ],
    youtube_shorts: [
      { hour: 15, day: [1, 2, 3, 4, 5] }, // 3 PM weekdays
      { hour: 21, day: [0, 6] }           // 9 PM weekends
    ],
    twitter: [
      { hour: 9, day: [1, 2, 3, 4, 5] },  // 9 AM weekdays
      { hour: 12, day: [1, 2, 3, 4, 5] }, // 12 PM weekdays
      { hour: 17, day: [1, 2, 3, 4, 5] }  // 5 PM weekdays
    ],
    facebook: [
      { hour: 13, day: [1, 2, 3, 4, 5] }, // 1 PM weekdays
      { hour: 15, day: [1, 2, 3, 4, 5] }  // 3 PM weekdays
    ]
  };
  
  const platformPeakTimes = peakTimes[platform] || peakTimes.twitter;
  
  // Get current day of week (0 = Sunday, 6 = Saturday)
  const now = new Date();
  const currentDay = now.getDay();
  
  // Find next optimal time
  const nextOptimalTimes = platformPeakTimes
    .filter(time => time.day.includes(currentDay))
    .map(time => {
      const optimalDate = new Date(now);
      optimalDate.setUTCHours(time.hour, 0, 0, 0);
      
      // If time has passed today, schedule for next occurrence
      if (optimalDate < now) {
        optimalDate.setDate(optimalDate.getDate() + 7);
      }
      
      return optimalDate;
    })
    .sort((a, b) => a - b);
  
  return {
    nextOptimalTime: nextOptimalTimes[0],
    allOptimalTimes: nextOptimalTimes,
    recommendation: `Best time to post: ${nextOptimalTimes[0].toLocaleString()}`
  };
}

// ============================================
// 5. CONTENT FORMATTING OPTIMIZER
// ============================================
function optimizeContentFormat(content, platform) {
  const { type, duration, aspectRatio } = content;
  
  const formatRules = {
    tiktok: {
      videoLength: { min: 15, max: 60, optimal: 30 },
      aspectRatio: '9:16',
      resolution: '1080x1920',
      fps: 30,
      format: 'mp4'
    },
    instagram: {
      videoLength: { min: 3, max: 60, optimal: 30 },
      aspectRatio: '9:16',
      resolution: '1080x1920',
      fps: 30,
      format: 'mp4'
    },
    youtube_shorts: {
      videoLength: { min: 15, max: 60, optimal: 45 },
      aspectRatio: '9:16',
      resolution: '1080x1920',
      fps: 30,
      format: 'mp4'
    },
    youtube: {
      videoLength: { min: 60, max: 600, optimal: 480 },
      aspectRatio: '16:9',
      resolution: '1920x1080',
      fps: 60,
      format: 'mp4'
    },
    twitter: {
      videoLength: { min: 5, max: 140, optimal: 45 },
      aspectRatio: '16:9',
      resolution: '1280x720',
      fps: 30,
      format: 'mp4'
    }
  };
  
  const rules = formatRules[platform] || formatRules.twitter;
  
  const recommendations = [];
  
  // Check video length
  if (type === 'video' && duration) {
    if (duration < rules.videoLength.min) {
      recommendations.push(`Video too short. Minimum: ${rules.videoLength.min}s`);
    } else if (duration > rules.videoLength.max) {
      recommendations.push(`Video too long. Maximum: ${rules.videoLength.max}s`);
    } else if (Math.abs(duration - rules.videoLength.optimal) > 15) {
      recommendations.push(`Optimal length: ${rules.videoLength.optimal}s (current: ${duration}s)`);
    }
  }
  
  // Check aspect ratio
  if (aspectRatio && aspectRatio !== rules.aspectRatio) {
    recommendations.push(`Recommended aspect ratio: ${rules.aspectRatio} (current: ${aspectRatio})`);
  }
  
  return {
    rules,
    recommendations,
    isOptimal: recommendations.length === 0
  };
}

// ============================================
// 6. MAIN OPTIMIZATION FUNCTION
// ============================================
async function optimizeForAlgorithm(content, platform, options = {}) {
  const {
    generateHooks = true,
    generateEngagement = true,
    optimizeCaptions = true,
    calculateTiming = true,
    generateHashtags = true,
    formatCheck = true
  } = options;
  
  const optimizations = {
    ...content,
    platform,
    optimized: true,
    optimizationTimestamp: new Date().toISOString()
  };
  
  // 1. Generate hook
  if (generateHooks) {
    optimizations.hook = generateHook(content, platform);
  }
  
  // 2. Generate engagement bait
  if (generateEngagement) {
    optimizations.engagementBait = generateEngagementBait(content, platform);
  }
  
  // 3. Optimize caption
  if (optimizeCaptions) {
    const captionData = optimizeCaption(content, platform);
    optimizations.optimizedCaption = captionData.caption;
    optimizations.captionMetadata = {
      maxLength: captionData.maxLength,
      recommendedHashtagCount: captionData.recommendedHashtagCount
    };
  }
  
  // 4. Calculate optimal posting time
  if (calculateTiming) {
    optimizations.optimalTiming = calculateOptimalPostingTime(platform, options.userTimezone, options.audienceData);
  }
  
  // 5. Generate hashtags
  if (generateHashtags) {
    const nicheTags = content.tags || [];
    optimizations.hashtags = generateCustomHashtags({
      content,
      platform,
      nicheTags
    });
  }
  
  // 6. Check content format
  if (formatCheck) {
    optimizations.formatOptimization = optimizeContentFormat(content, platform);
  }
  
  // 7. Generate optimization score
  optimizations.optimizationScore = calculateOptimizationScore(optimizations);
  
  return optimizations;
}

// ============================================
// 7. OPTIMIZATION SCORE CALCULATOR
// ============================================
function calculateOptimizationScore(optimizedContent) {
  let score = 0;
  const maxScore = 100;
  
  // Hook present (+20)
  if (optimizedContent.hook) score += 20;
  
  // Engagement bait present (+20)
  if (optimizedContent.engagementBait) score += 20;
  
  // Caption optimized (+15)
  if (optimizedContent.optimizedCaption) score += 15;
  
  // Hashtags present (+15)
  if (optimizedContent.hashtags && optimizedContent.hashtags.length > 0) score += 15;
  
  // Optimal timing calculated (+10)
  if (optimizedContent.optimalTiming) score += 10;
  
  // Format is optimal (+20)
  if (optimizedContent.formatOptimization && optimizedContent.formatOptimization.isOptimal) {
    score += 20;
  } else if (optimizedContent.formatOptimization) {
    score += 10; // Partial credit if format checked but not optimal
  }
  
  return {
    score,
    maxScore,
    percentage: Math.round((score / maxScore) * 100),
    grade: score >= 80 ? 'A' : score >= 60 ? 'B' : score >= 40 ? 'C' : 'D'
  };
}

// ============================================
// EXPORTS
// ============================================
module.exports = {
  optimizeForAlgorithm,
  generateHook,
  generateEngagementBait,
  optimizeCaption,
  calculateOptimalPostingTime,
  optimizeContentFormat,
  calculateOptimizationScore
=======
/**
 * Match trending sound for content
 * @param {object} content - Content object
 * @param {string} platform - Platform name
 * @returns {object} Matched sound
 */
function matchTrendingSound(content, platform) {
  const sounds = TRENDING_SOUNDS[platform] || TRENDING_SOUNDS.tiktok;
  const category = content.category || 'general';
  
  // Find sounds matching category
  let matchingSounds = sounds.filter(s => s.category === category);
  
  // If no match, use general sounds
  if (matchingSounds.length === 0) {
    matchingSounds = sounds;
  }
  
  // Sort by popularity and pick top one
  matchingSounds.sort((a, b) => b.popularity - a.popularity);
  const selectedSound = matchingSounds[0];
  
  return {
    soundId: selectedSound.id,
    soundName: selectedSound.name,
    category: selectedSound.category,
    popularity: selectedSound.popularity,
    platform,
    recommendation: 'Use this trending sound for maximum reach'
  };
}

/**
 * Generate engagement bait
 * @param {string} type - Type of engagement bait (questions, controversy, challenges, cta)
 * @param {object} content - Content object
 * @returns {string} Engagement bait text
 */
function generateEngagementBait(type = 'questions', content = {}) {
  const templates = ENGAGEMENT_BAIT[type] || ENGAGEMENT_BAIT.questions;
  let bait = templates[Math.floor(Math.random() * templates.length)];
  
  // Replace placeholders
  if (bait.includes('{statement}') && content.title) {
    bait = bait.replace('{statement}', content.title);
  }
  
  return bait;
}

/**
 * Optimize caption timing for video
 * @param {string} platform - Platform name
 * @param {number} videoDuration - Video duration in seconds
 * @returns {object} Caption timing recommendations
 */
function optimizeCaptionTiming(platform, videoDuration) {
  const timing = CAPTION_TIMING[platform] || CAPTION_TIMING.tiktok;
  const recommendations = [];
  
  // Hook timing
  recommendations.push({
    type: 'hook',
    text: 'Attention-grabbing hook',
    startTime: timing.hook.start,
    endTime: Math.min(timing.hook.end, videoDuration),
    position: timing.hook.position,
    priority: 'critical'
  });
  
  // Main content timing
  if (videoDuration > timing.main.start) {
    recommendations.push({
      type: 'main',
      text: 'Main content text',
      startTime: timing.main.start,
      endTime: Math.min(timing.main.end, videoDuration),
      position: timing.main.position,
      priority: 'high'
    });
  }
  
  // CTA timing
  if (videoDuration > timing.cta.start) {
    recommendations.push({
      type: 'cta',
      text: 'Call-to-action',
      startTime: timing.cta.start,
      endTime: Math.min(timing.cta.end, videoDuration),
      position: timing.cta.position,
      priority: 'medium'
    });
  }
  
  return {
    platform,
    videoDuration,
    recommendations,
    totalOverlays: recommendations.length
  };
}

/**
 * Optimize video length and pacing
 * @param {object} content - Content object
 * @param {string} platform - Platform name
 * @returns {object} Pacing recommendations
 */
function optimizeLengthAndPacing(content, platform) {
  const rules = PACING_RULES[platform] || PACING_RULES.tiktok;
  const currentLength = content.duration || 30;
  
  const recommendations = [];
  
  // Length optimization
  if (currentLength !== rules.optimalLength) {
    recommendations.push({
      type: 'length',
      current: currentLength,
      optimal: rules.optimalLength,
      message: `Adjust video length to ${rules.optimalLength} seconds for optimal performance`,
      impact: 'high'
    });
  }
  
  // Cut frequency
  const recommendedCuts = Math.floor(currentLength / rules.cutFrequency);
  recommendations.push({
    type: 'cuts',
    recommended: recommendedCuts,
    frequency: rules.cutFrequency,
    message: `Add ${recommendedCuts} cuts (every ${rules.cutFrequency} seconds) to maintain engagement`,
    impact: 'high'
  });
  
  // Pattern interrupts
  recommendations.push({
    type: 'pattern_interrupts',
    recommended: rules.patternInterrupts,
    message: `Include ${rules.patternInterrupts} pattern interrupts (zoom, text, sound effects)`,
    impact: 'medium'
  });
  
  // Text overlays
  if (rules.textOverlays) {
    recommendations.push({
      type: 'text_overlays',
      message: 'Add text overlays for better retention and accessibility',
      impact: 'medium'
    });
  }
  
  // Transitions
  recommendations.push({
    type: 'transitions',
    style: rules.transitions,
    message: `Use ${rules.transitions} transitions between scenes`,
    impact: 'low'
  });
  
  return {
    platform,
    currentLength,
    optimalLength: rules.optimalLength,
    recommendations,
    pacingScore: calculatePacingScore(currentLength, rules)
  };
}

/**
 * Calculate pacing score
 * @param {number} currentLength - Current video length
 * @param {object} rules - Pacing rules
 * @returns {number} Score from 0-100
 */
function calculatePacingScore(currentLength, rules) {
  const lengthDiff = Math.abs(currentLength - rules.optimalLength);
  const lengthScore = Math.max(0, 100 - (lengthDiff * 2));
  return Math.round(lengthScore);
}

/**
 * Comprehensive algorithm optimization
 * @param {object} content - Content object
 * @param {string} platform - Platform name
 * @param {object} options - Additional options
 * @returns {object} Complete optimization package
 */
function optimizeForAlgorithm(content, platform, options = {}) {
  const category = content.category || 'entertainment';
  
  // Generate hook
  const hook = generateHook(content, category);
  
  // Match trending sound
  const trendingSound = matchTrendingSound(content, platform);
  
  // Generate engagement bait (mix of types)
  const engagementBait = {
    question: generateEngagementBait('questions', content),
    cta: generateEngagementBait('cta', content),
    challenge: generateEngagementBait('challenges', content)
  };
  
  // Optimize caption timing
  const captionTiming = optimizeCaptionTiming(platform, content.duration || 30);
  
  // Optimize length and pacing
  const pacing = optimizeLengthAndPacing(content, platform);
  
  // Calculate overall optimization score
  const optimizationScore = calculateOverallOptimizationScore({
    hook,
    trendingSound,
    engagementBait,
    captionTiming,
    pacing
  });
  
  return {
    contentId: content.id,
    platform,
    category,
    hook,
    trendingSound,
    engagementBait,
    captionTiming,
    pacing,
    optimizationScore,
    optimized: true,
    optimizedAt: new Date().toISOString(),
    recommendations: generateOptimizationRecommendations(optimizationScore, pacing)
  };
}

/**
 * Calculate overall optimization score
 * @param {object} components - Optimization components
 * @returns {number} Score from 0-100
 */
function calculateOverallOptimizationScore(components) {
  let score = 0;
  
  // Hook (25 points)
  if (components.hook) score += 25;
  
  // Trending sound (25 points)
  if (components.trendingSound && components.trendingSound.popularity > 80) {
    score += 25;
  } else if (components.trendingSound) {
    score += 15;
  }
  
  // Engagement bait (25 points)
  const baitCount = Object.keys(components.engagementBait || {}).length;
  score += Math.min(25, baitCount * 8);
  
  // Pacing (25 points)
  if (components.pacing) {
    score += (components.pacing.pacingScore / 100) * 25;
  }
  
  return Math.round(score);
}

/**
 * Generate optimization recommendations
 * @param {number} score - Current optimization score
 * @param {object} pacing - Pacing data
 * @returns {Array} Recommendations
 */
function generateOptimizationRecommendations(score, pacing) {
  const recommendations = [];
  
  if (score < 70) {
    recommendations.push({
      priority: 'high',
      message: 'Content needs significant optimization for algorithm success',
      actions: ['Add compelling hook', 'Use trending sound', 'Optimize video length']
    });
  } else if (score < 85) {
    recommendations.push({
      priority: 'medium',
      message: 'Content is good but can be improved',
      actions: ['Fine-tune pacing', 'Add more engagement bait', 'Optimize caption timing']
    });
  } else {
    recommendations.push({
      priority: 'low',
      message: 'Content is well-optimized for algorithm success',
      actions: ['Monitor performance', 'Test variations', 'Scale promotion']
    });
  }
  
  // Add pacing-specific recommendations
  if (pacing && pacing.recommendations) {
    pacing.recommendations.forEach(rec => {
      if (rec.impact === 'high') {
        recommendations.push({
          priority: 'high',
          message: rec.message,
          type: rec.type
        });
      }
    });
  }
  
  return recommendations;
}

/**
 * Save optimization data to database
 * @param {object} optimizationData - Optimization data
 * @returns {Promise<object>} Save result
 */
async function saveOptimizationData(optimizationData) {
  try {
    const optRef = db.collection('algorithm_optimizations').doc();
    await optRef.set({
      ...optimizationData,
      id: optRef.id,
      createdAt: new Date().toISOString()
    });
    
    return {
      success: true,
      optimizationId: optRef.id
    };
  } catch (error) {
    console.error('Error saving optimization data:', error);
    return { success: false, error: error.message };
  }
}

module.exports = {
  optimizeForAlgorithm,
  generateHook,
  matchTrendingSound,
  generateEngagementBait,
  optimizeCaptionTiming,
  optimizeLengthAndPacing,
  saveOptimizationData,
  HOOK_TEMPLATES,
  ENGAGEMENT_BAIT,
  TRENDING_SOUNDS,
  CAPTION_TIMING,
  PACING_RULES
>>>>>>> Stashed changes
};
