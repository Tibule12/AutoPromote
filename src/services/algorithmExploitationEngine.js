// algorithmExploitationEngine.js
// AutoPromote Algorithmic Exploitation Logic
// Maximizes algorithmic favor with hooks, trending sounds, engagement bait, optimal timing

const { generateCustomHashtags } = require('./hashtagEngine');

// ============================================
// 1. HOOK GENERATOR
// ============================================
const HOOK_TEMPLATES = {
  question: [
    "Did you know {topic}?",
    "What if I told you {topic}?",
    "Can you believe {topic}?",
    "Why does {topic}?",
    "How to {topic} in 60 seconds"
  ],
  controversy: [
    "Everyone is wrong about {topic}",
    "The truth about {topic} nobody tells you",
    "Stop doing {topic} - here's why",
    "{topic} is a lie - here's proof",
    "I tried {topic} for 30 days - shocking results"
  ],
  urgency: [
    "You need to see this before {topic}",
    "This {topic} trick changes everything",
    "Don't scroll past this {topic}",
    "Last chance to {topic}",
    "Only {number} people know this {topic} secret"
  ],
  curiosity: [
    "The secret to {topic} revealed",
    "What happens when you {topic}",
    "Nobody expected this {topic} result",
    "This {topic} will blow your mind",
    "Watch what happens when {topic}"
  ],
  emotional: [
    "This {topic} made me cry",
    "You won't believe this {topic} story",
    "The most {emotion} {topic} ever",
    "This {topic} will change your life",
    "I can't stop thinking about {topic}"
  ]
};

function generateHook(content, platform) {
  const { title, description, category, type } = content;
  const topic = title || category || 'this';
  
  // Select hook type based on platform
  let hookType;
  if (platform === 'tiktok' || platform === 'youtube_shorts') {
    hookType = Math.random() > 0.5 ? 'curiosity' : 'urgency';
  } else if (platform === 'twitter') {
    hookType = Math.random() > 0.5 ? 'question' : 'controversy';
  } else if (platform === 'youtube') {
    hookType = 'curiosity';
  } else {
    hookType = 'question';
  }
  
  const templates = HOOK_TEMPLATES[hookType];
  const template = templates[Math.floor(Math.random() * templates.length)];
  
  // Replace placeholders
  const hook = template
    .replace('{topic}', topic)
    .replace('{emotion}', ['inspiring', 'shocking', 'heartwarming', 'unbelievable'][Math.floor(Math.random() * 4)])
    .replace('{number}', [5, 10, 100, 1000][Math.floor(Math.random() * 4)]);
  
  return hook;
}

// ============================================
// 2. ENGAGEMENT BAIT GENERATOR
// ============================================
const ENGAGEMENT_PATTERNS = {
  comment: [
    "Comment '{word}' if you agree",
    "Drop a {emoji} in the comments",
    "Tell me your {topic} story below",
    "Which one are you? Comment below",
    "Tag someone who needs to see this"
  ],
  share: [
    "Share this with someone who {action}",
    "Send this to your {person}",
    "Repost if you {feeling}",
    "Share to save for later",
    "Tag 3 friends who need this"
  ],
  follow: [
    "Follow for more {topic} content",
    "Follow if you want to see part 2",
    "Hit follow for daily {topic} tips",
    "Follow for the full tutorial",
    "Don't miss part 2 - follow now"
  ],
  like: [
    "Double tap if you {feeling}",
    "Like if this helped you",
    "Heart this if you agree",
    "Smash that like button",
    "Show some love if you enjoyed this"
  ]
};

function generateEngagementBait(content, platform) {
  const { category, type } = content;
  
  // Select engagement type based on platform
  let engagementTypes;
  if (platform === 'tiktok') {
    engagementTypes = ['comment', 'share', 'follow'];
  } else if (platform === 'youtube' || platform === 'youtube_shorts') {
    engagementTypes = ['comment', 'like', 'follow'];
  } else if (platform === 'twitter') {
    engagementTypes = ['comment', 'share'];
  } else {
    engagementTypes = ['comment', 'like'];
  }
  
  const selectedType = engagementTypes[Math.floor(Math.random() * engagementTypes.length)];
  const templates = ENGAGEMENT_PATTERNS[selectedType];
  const template = templates[Math.floor(Math.random() * templates.length)];
  
  // Replace placeholders
  const bait = template
    .replace('{word}', ['YES', 'FACTS', 'REAL', 'TRUE'][Math.floor(Math.random() * 4)])
    .replace('{emoji}', ['ðŸ”¥', 'ðŸ’¯', 'ðŸ‘‡', 'â¤ï¸', 'ðŸš€'][Math.floor(Math.random() * 5)])
    .replace('{topic}', category || 'this')
    .replace('{action}', ['needs this', 'loves this', 'should see this'][Math.floor(Math.random() * 3)])
    .replace('{person}', ['best friend', 'squad', 'family', 'followers'][Math.floor(Math.random() * 4)])
    .replace('{feeling}', ['relate', 'agree', 'love this', 'needed this'][Math.floor(Math.random() * 4)]);
  
  return bait;
}

// ============================================
// 3. CAPTION OPTIMIZER
// ============================================
function optimizeCaption(content, platform) {
  const { title, description, category } = content;
  let caption = description || title || '';
  
  // Platform-specific caption rules
  const rules = {
    tiktok: { maxLength: 150, emojiDensity: 'high', hashtagCount: 5 },
    instagram: { maxLength: 2200, emojiDensity: 'medium', hashtagCount: 10 },
    youtube: { maxLength: 5000, emojiDensity: 'low', hashtagCount: 3 },
    youtube_shorts: { maxLength: 100, emojiDensity: 'high', hashtagCount: 5 },
    twitter: { maxLength: 280, emojiDensity: 'medium', hashtagCount: 3 },
    facebook: { maxLength: 63206, emojiDensity: 'low', hashtagCount: 5 }
  };
  
  const platformRules = rules[platform] || rules.twitter;
  
  // Truncate if too long
  if (caption.length > platformRules.maxLength) {
    caption = caption.substring(0, platformRules.maxLength - 3) + '...';
  }
  
  // Add emojis based on density
  const emojis = ['ðŸ”¥', 'ðŸ’¯', 'âœ¨', 'ðŸš€', 'ðŸ’ª', 'ðŸ‘€', 'ðŸŽ¯', 'âš¡'];
  if (platformRules.emojiDensity === 'high' && !caption.match(/[\u{1F300}-\u{1F9FF}]/u)) {
    caption = `${emojis[Math.floor(Math.random() * emojis.length)]} ${caption}`;
  }
  
  // Add line breaks for readability (except Twitter)
  if (platform !== 'twitter' && caption.length > 100) {
    caption = caption.replace(/\. /g, '.\n\n');
  }
  
  return {
    caption,
    maxLength: platformRules.maxLength,
    recommendedHashtagCount: platformRules.hashtagCount
  };
}

// ============================================
// 4. OPTIMAL POSTING TIME CALCULATOR
// ============================================
function calculateOptimalPostingTime(platform, userTimezone = 'UTC', audienceData = null) {
  // Peak engagement times by platform (in UTC)
  const peakTimes = {
    tiktok: [
      { hour: 14, day: [1, 2, 3, 4, 5] }, // 2 PM weekdays
      { hour: 18, day: [1, 2, 3, 4, 5] }, // 6 PM weekdays
      { hour: 11, day: [0, 6] }           // 11 AM weekends
    ],
    instagram: [
      { hour: 11, day: [1, 2, 3, 4, 5] }, // 11 AM weekdays
      { hour: 14, day: [1, 2, 3, 4, 5] }, // 2 PM weekdays
      { hour: 19, day: [0, 6] }           // 7 PM weekends
    ],
    youtube: [
      { hour: 14, day: [1, 2, 3, 4, 5] }, // 2 PM weekdays
      { hour: 20, day: [0, 6] }           // 8 PM weekends
    ],
    youtube_shorts: [
      { hour: 15, day: [1, 2, 3, 4, 5] }, // 3 PM weekdays
      { hour: 21, day: [0, 6] }           // 9 PM weekends
    ],
    twitter: [
      { hour: 9, day: [1, 2, 3, 4, 5] },  // 9 AM weekdays
      { hour: 12, day: [1, 2, 3, 4, 5] }, // 12 PM weekdays
      { hour: 17, day: [1, 2, 3, 4, 5] }  // 5 PM weekdays
    ],
    facebook: [
      { hour: 13, day: [1, 2, 3, 4, 5] }, // 1 PM weekdays
      { hour: 15, day: [1, 2, 3, 4, 5] }  // 3 PM weekdays
    ]
  };
  
  const platformPeakTimes = peakTimes[platform] || peakTimes.twitter;
  
  // Get current day of week (0 = Sunday, 6 = Saturday)
  const now = new Date();
  const currentDay = now.getDay();
  
  // Find next optimal time
  const nextOptimalTimes = platformPeakTimes
    .filter(time => time.day.includes(currentDay))
    .map(time => {
      const optimalDate = new Date(now);
      optimalDate.setUTCHours(time.hour, 0, 0, 0);
      
      // If time has passed today, schedule for next occurrence
      if (optimalDate < now) {
        optimalDate.setDate(optimalDate.getDate() + 7);
      }
      
      return optimalDate;
    })
    .sort((a, b) => a - b);
  
  return {
    nextOptimalTime: nextOptimalTimes[0],
    allOptimalTimes: nextOptimalTimes,
    recommendation: `Best time to post: ${nextOptimalTimes[0].toLocaleString()}`
  };
}

// ============================================
// 5. CONTENT FORMATTING OPTIMIZER
// ============================================
function optimizeContentFormat(content, platform) {
  const { type, duration, aspectRatio } = content;
  
  const formatRules = {
    tiktok: {
      videoLength: { min: 15, max: 60, optimal: 30 },
      aspectRatio: '9:16',
      resolution: '1080x1920',
      fps: 30,
      format: 'mp4'
    },
    instagram: {
      videoLength: { min: 3, max: 60, optimal: 30 },
      aspectRatio: '9:16',
      resolution: '1080x1920',
      fps: 30,
      format: 'mp4'
    },
    youtube_shorts: {
      videoLength: { min: 15, max: 60, optimal: 45 },
      aspectRatio: '9:16',
      resolution: '1080x1920',
      fps: 30,
      format: 'mp4'
    },
    youtube: {
      videoLength: { min: 60, max: 600, optimal: 480 },
      aspectRatio: '16:9',
      resolution: '1920x1080',
      fps: 60,
      format: 'mp4'
    },
    twitter: {
      videoLength: { min: 5, max: 140, optimal: 45 },
      aspectRatio: '16:9',
      resolution: '1280x720',
      fps: 30,
      format: 'mp4'
    }
  };
  
  const rules = formatRules[platform] || formatRules.twitter;
  
  const recommendations = [];
  
  // Check video length
  if (type === 'video' && duration) {
    if (duration < rules.videoLength.min) {
      recommendations.push(`Video too short. Minimum: ${rules.videoLength.min}s`);
    } else if (duration > rules.videoLength.max) {
      recommendations.push(`Video too long. Maximum: ${rules.videoLength.max}s`);
    } else if (Math.abs(duration - rules.videoLength.optimal) > 15) {
      recommendations.push(`Optimal length: ${rules.videoLength.optimal}s (current: ${duration}s)`);
    }
  }
  
  // Check aspect ratio
  if (aspectRatio && aspectRatio !== rules.aspectRatio) {
    recommendations.push(`Recommended aspect ratio: ${rules.aspectRatio} (current: ${aspectRatio})`);
  }
  
  return {
    rules,
    recommendations,
    isOptimal: recommendations.length === 0
  };
}

// ============================================
// 6. MAIN OPTIMIZATION FUNCTION
// ============================================
async function optimizeForAlgorithm(content, platform, options = {}) {
  const {
    generateHooks = true,
    generateEngagement = true,
    optimizeCaptions = true,
    calculateTiming = true,
    generateHashtags = true,
    formatCheck = true
  } = options;
  
  const optimizations = {
    ...content,
    platform,
    optimized: true,
    optimizationTimestamp: new Date().toISOString()
  };
  
  // 1. Generate hook
  if (generateHooks) {
    optimizations.hook = generateHook(content, platform);
  }
  
  // 2. Generate engagement bait
  if (generateEngagement) {
    optimizations.engagementBait = generateEngagementBait(content, platform);
  }
  
  // 3. Optimize caption
  if (optimizeCaptions) {
    const captionData = optimizeCaption(content, platform);
    optimizations.optimizedCaption = captionData.caption;
    optimizations.captionMetadata = {
      maxLength: captionData.maxLength,
      recommendedHashtagCount: captionData.recommendedHashtagCount
    };
  }
  
  // 4. Calculate optimal posting time
  if (calculateTiming) {
    optimizations.optimalTiming = calculateOptimalPostingTime(platform, options.userTimezone, options.audienceData);
  }
  
  // 5. Generate hashtags
  if (generateHashtags) {
    const nicheTags = content.tags || [];
    optimizations.hashtags = generateCustomHashtags({
      content,
      platform,
      nicheTags
    });
  }
  
  // 6. Check content format
  if (formatCheck) {
    optimizations.formatOptimization = optimizeContentFormat(content, platform);
  }
  
  // 7. Generate optimization score
  optimizations.optimizationScore = calculateOptimizationScore(optimizations);
  
  return optimizations;
}

// ============================================
// 7. OPTIMIZATION SCORE CALCULATOR
// ============================================
function calculateOptimizationScore(optimizedContent) {
  let score = 0;
  const maxScore = 100;
  
  // Hook present (+20)
  if (optimizedContent.hook) score += 20;
  
  // Engagement bait present (+20)
  if (optimizedContent.engagementBait) score += 20;
  
  // Caption optimized (+15)
  if (optimizedContent.optimizedCaption) score += 15;
  
  // Hashtags present (+15)
  if (optimizedContent.hashtags && optimizedContent.hashtags.length > 0) score += 15;
  
  // Optimal timing calculated (+10)
  if (optimizedContent.optimalTiming) score += 10;
  
  // Format is optimal (+20)
  if (optimizedContent.formatOptimization && optimizedContent.formatOptimization.isOptimal) {
    score += 20;
  } else if (optimizedContent.formatOptimization) {
    score += 10; // Partial credit if format checked but not optimal
  }
  
  return {
    score,
    maxScore,
    percentage: Math.round((score / maxScore) * 100),
    grade: score >= 80 ? 'A' : score >= 60 ? 'B' : score >= 40 ? 'C' : 'D'
  };
}

// ============================================
// EXPORTS
// ============================================
module.exports = {
  optimizeForAlgorithm,
  generateHook,
  generateEngagementBait,
  optimizeCaption,
  calculateOptimalPostingTime,
  optimizeContentFormat,
  calculateOptimizationScore
};
