// hashtagEngine.js
// AutoPromote Hashtag Engine: Generates custom, algorithm-breaking hashtags for every post
// Features: trending/niche blend, rotation, spam avoidance, performance tracking, branded communities

const fetch = require('node-fetch');
const { db } = require('../firebaseAdmin');

// Comprehensive trending hashtags database by platform and category
const TRENDING_HASHTAGS = {
  tiktok: {
    general: ['#fyp', '#foryou', '#foryoupage', '#viral', '#trending', '#tiktok', '#viralvideo', '#fypã‚·'],
    entertainment: ['#comedy', '#funny', '#entertainment', '#memes', '#funnyvideos', '#laugh', '#humor'],
    lifestyle: ['#lifestyle', '#dailyvlog', '#dayinmylife', '#aesthetic', '#motivation', '#selfcare'],
    beauty: ['#beauty', '#makeup', '#skincare', '#beautytips', '#makeuptutorial', '#glowup'],
    fitness: ['#fitness', '#workout', '#gym', '#fitnessmotivation', '#health', '#exercise'],
    food: ['#food', '#foodie', '#cooking', '#recipe', '#foodtiktok', '#easyrecipe'],
    dance: ['#dance', '#dancechallenge', '#dancer', '#choreography', '#dancevideo'],
    music: ['#music', '#song', '#singer', '#musician', '#cover', '#originalsound'],
    education: ['#learn', '#educational', '#tutorial', '#howto', '#tips', '#lifehack'],
    gaming: ['#gaming', '#gamer', '#gameplay', '#videogames', '#gamingcommunity']
  },
  instagram: {
    general: ['#instagood', '#instagram', '#explorepage', '#explore', '#viral', '#reels', '#reelsinstagram', '#trending'],
    entertainment: ['#entertainment', '#fun', '#funny', '#comedy', '#meme', '#instafun'],
    lifestyle: ['#lifestyle', '#lifestyleblogger', '#dailylife', '#inspiration', '#motivation', '#goals'],
    beauty: ['#beauty', '#beautyblogger', '#makeup', '#makeupoftheday', '#skincare', '#beautytips'],
    fitness: ['#fitness', '#fitnessmotivation', '#workout', '#gym', '#fit', '#health', '#fitfam'],
    food: ['#food', '#foodporn', '#foodie', '#instafood', '#foodphotography', '#yummy', '#delicious'],
    fashion: ['#fashion', '#style', '#ootd', '#fashionblogger', '#fashionista', '#outfitoftheday'],
    travel: ['#travel', '#travelphotography', '#wanderlust', '#instatravel', '#travelgram', '#adventure'],
    photography: ['#photography', '#photooftheday', '#photo', '#photographer', '#instagood', '#picoftheday'],
    business: ['#business', '#entrepreneur', '#success', '#motivation', '#businessowner', '#startup']
  },
  youtube: {
    general: ['#shorts', '#youtubeshorts', '#viral', '#trending', '#youtube', '#subscribe', '#youtuber'],
    entertainment: ['#entertainment', '#funny', '#comedy', '#funnyvideo', '#entertainment'],
    gaming: ['#gaming', '#gameplay', '#gamer', '#gamingvideos', '#letsplay', '#videogames'],
    education: ['#educational', '#tutorial', '#howto', '#learn', '#education', '#tips'],
    tech: ['#tech', '#technology', '#gadgets', '#review', '#unboxing', '#techreview'],
    music: ['#music', '#musicvideo', '#song', '#newmusic', '#musician', '#cover'],
    vlog: ['#vlog', '#vlogger', '#dailyvlog', '#lifestyle', '#vlogging', '#youtuber'],
    cooking: ['#cooking', '#recipe', '#food', '#cookingtutorial', '#chef', '#foodie'],
    fitness: ['#fitness', '#workout', '#exercise', '#fitnessmotivation', '#gym', '#health'],
    diy: ['#diy', '#crafts', '#diyprojects', '#handmade', '#creative', '#howtomake']
  },
  twitter: {
    general: ['#Viral', '#Trending', '#Twitter', '#Tweet', '#RT', '#Retweet', '#Follow'],
    news: ['#News', '#Breaking', '#BreakingNews', '#Update', '#Latest', '#CurrentEvents'],
    entertainment: ['#Entertainment', '#Movies', '#TV', '#Music', '#Celebrity', '#Pop'],
    sports: ['#Sports', '#Game', '#Live', '#Score', '#Team', '#Match', '#Championship'],
    tech: ['#Tech', '#Technology', '#Innovation', '#AI', '#Startup', '#Digital'],
    business: ['#Business', '#Marketing', '#Entrepreneur', '#Success', '#Leadership', '#Growth'],
    lifestyle: ['#Lifestyle', '#Motivation', '#Inspiration', '#Goals', '#Success', '#Life'],
    politics: ['#Politics', '#Election', '#Vote', '#Government', '#Policy', '#Democracy'],
    health: ['#Health', '#Wellness', '#Fitness', '#Healthcare', '#Medical', '#Nutrition'],
    education: ['#Education', '#Learning', '#Teaching', '#School', '#University', '#Knowledge']
  },
  facebook: {
    general: ['#Facebook', '#Viral', '#Trending', '#Share', '#Like', '#Follow'],
    family: ['#Family', '#FamilyTime', '#Love', '#Kids', '#Parenting', '#FamilyLife'],
    lifestyle: ['#Lifestyle', '#Life', '#Daily', '#Inspiration', '#Motivation', '#Happy'],
    business: ['#Business', '#SmallBusiness', '#Entrepreneur', '#Marketing', '#Sales', '#Success'],
    community: ['#Community', '#Local', '#Support', '#Together', '#Unity', '#Help'],
    events: ['#Event', '#Events', '#Party', '#Celebration', '#Gathering', '#Festival'],
    food: ['#Food', '#Foodie', '#Cooking', '#Recipe', '#Delicious', '#Yummy'],
    travel: ['#Travel', '#Vacation', '#Trip', '#Adventure', '#Explore', '#Wanderlust'],
    health: ['#Health', '#Wellness', '#Fitness', '#Healthy', '#Healthcare', '#Wellbeing'],
    entertainment: ['#Entertainment', '#Fun', '#Funny', '#Comedy', '#Music', '#Movies']
  }
};

// Niche hashtag database by category
const NICHE_HASHTAGS = {
  entertainment: ['#entertainmentindustry', '#entertainmentnews', '#entertainmenttonight', '#entertainmentweekly'],
  lifestyle: ['#lifestylephotography', '#lifestylechange', '#lifestyledesign', '#lifestylegoals'],
  beauty: ['#beautycommunity', '#beautyproducts', '#beautyaddict', '#beautyinfluencer'],
  fitness: ['#fitnessjourney', '#fitnessgoals', '#fitnesslife', '#fitnessaddict'],
  food: ['#foodblogger', '#foodlover', '#foodstagram', '#foodgasm'],
  tech: ['#techie', '#techlover', '#technews', '#techtrends'],
  gaming: ['#gaminglife', '#gamingsetup', '#gamingpc', '#gamingchannel'],
  music: ['#musiclover', '#musicproducer', '#musiclife', '#musicislife'],
  fashion: ['#fashionweek', '#fashiondesigner', '#fashiontrends', '#fashionlover'],
  travel: ['#travelblogger', '#traveladdict', '#traveltheworld', '#travelpics'],
  business: ['#businessmindset', '#businessgrowth', '#businesstips', '#businesslife'],
  education: ['#educationmatters', '#educationfirst', '#educationforall', '#educationiskey'],
  art: ['#artist', '#artwork', '#artistic', '#artoftheday', '#artcommunity'],
  photography: ['#photographylovers', '#photographylife', '#photographyislife', '#photographyeveryday'],
  motivation: ['#motivationalquotes', '#motivationmonday', '#motivationalspeaker', '#motivationoftheday']
};

// Branded AutoPromote hashtags
const BRANDED_HASHTAGS = {
  core: ['#AutoPromoteBoosted', '#AutoPromoteViral', '#AutoPromoteGrowth', '#AutoPromoteSuccess'],
  platform: {
    tiktok: ['#AutoPromoteTikTok', '#TikTokGrowth', '#TikTokViral', '#TikTokBoosted'],
    instagram: ['#AutoPromoteIG', '#IGGrowth', '#InstaViral', '#InstaBoosted'],
    youtube: ['#AutoPromoteYT', '#YouTubeGrowth', '#YouTubeViral', '#YTBoosted'],
    twitter: ['#AutoPromoteTwitter', '#TwitterGrowth', '#TwitterViral', '#TwitterBoosted'],
    facebook: ['#AutoPromoteFB', '#FacebookGrowth', '#FBViral', '#FBBoosted']
  },
  community: ['#AutoPromoteSquad', '#AutoPromoteCommunity', '#AutoPromoteFamily', '#AutoPromoteNation'],
  guarantee: ['#GuaranteedGrowth', '#GrowthGuarantee', '#ViralGuarantee', '#20KViews']
};

// Hashtag rotation tracker to avoid spam filters
const hashtagRotationCache = new Map();

/**
 * Get trending hashtags for a platform with real-time data
 * @param {string} platform - Platform name (tiktok, instagram, youtube, twitter, facebook)
 * @param {string} category - Content category (optional)
 * @returns {Promise<string[]>} Array of trending hashtags
 */
async function getTrendingHashtags(platform, category = 'general') {
  try {
    // Try to fetch real-time trending hashtags (implement API calls here)
    // For now, return from our comprehensive database
    const platformTags = TRENDING_HASHTAGS[platform] || TRENDING_HASHTAGS.tiktok;
    const categoryTags = platformTags[category] || platformTags.general;
    
    // Shuffle and return top trending
    return shuffleArray(categoryTags).slice(0, 10);
  } catch (error) {
    console.error('Error fetching trending hashtags:', error);
    return TRENDING_HASHTAGS[platform]?.general || [];
  }
}

/**
 * Get niche hashtags for a category
 * @param {string} category - Content category
 * @returns {string[]} Array of niche hashtags
 */
function getNicheHashtags(category) {
  const niche = NICHE_HASHTAGS[category] || [];
  const related = [];
  
  // Add related niche tags
  if (category === 'entertainment') {
    related.push(...(NICHE_HASHTAGS.music || []), ...(NICHE_HASHTAGS.art || []));
  } else if (category === 'lifestyle') {
    related.push(...(NICHE_HASHTAGS.fashion || []), ...(NICHE_HASHTAGS.travel || []));
  } else if (category === 'tech') {
    related.push(...(NICHE_HASHTAGS.gaming || []), ...(NICHE_HASHTAGS.business || []));
  }
  
  return [...niche, ...related].slice(0, 15);
}

/**
 * Get branded hashtags for platform and content
 * @param {string} platform - Platform name
 * @param {object} options - Additional options
 * @returns {string[]} Array of branded hashtags
 */
function getBrandedHashtags(platform, options = {}) {
  const branded = [...BRANDED_HASHTAGS.core];
  
  // Add platform-specific branded tags
  if (BRANDED_HASHTAGS.platform[platform]) {
    branded.push(...BRANDED_HASHTAGS.platform[platform]);
  }
  
  // Add community tags
  branded.push(...BRANDED_HASHTAGS.community.slice(0, 2));
  
  // Add guarantee tags if applicable
  if (options.growthGuarantee) {
    branded.push(...BRANDED_HASHTAGS.guarantee.slice(0, 2));
  }
  
  return branded;
}

/**
 * Generate custom, algorithm-breaking hashtags for content
 * @param {object} params - Generation parameters
 * @param {object} params.content - Content object with title, description, category
 * @param {string} params.platform - Target platform
 * @param {string[]} params.customTags - User-provided custom tags
 * @param {boolean} params.growthGuarantee - Whether content has growth guarantee
 * @returns {Promise<object>} Generated hashtags with metadata
 */
async function generateCustomHashtags({ content, platform, customTags = [], growthGuarantee = true }) {
  try {
    const category = content.category || detectCategory(content);
    
    // Get trending hashtags (40% of total)
    const trending = await getTrendingHashtags(platform, category);
    const trendingCount = Math.ceil(12 * 0.4); // 40% of 12 = ~5 tags
    
    // Get niche hashtags (40% of total)
    const niche = getNicheHashtags(category);
    const nicheCount = Math.ceil(12 * 0.4); // 40% of 12 = ~5 tags
    
    // Get branded hashtags (20% of total)
    const branded = getBrandedHashtags(platform, { growthGuarantee });
    const brandedCount = Math.ceil(12 * 0.2); // 20% of 12 = ~2 tags
    
    // Apply rotation to avoid spam filters
    const rotatedTrending = rotateHashtags(trending, `${platform}-trending`, trendingCount);
    const rotatedNiche = rotateHashtags(niche, `${platform}-${category}-niche`, nicheCount);
    const rotatedBranded = rotateHashtags(branded, `${platform}-branded`, brandedCount);
    
    // Combine all hashtags
    let allHashtags = [
      ...rotatedTrending,
      ...rotatedNiche,
      ...rotatedBranded,
      ...customTags.slice(0, 3) // Add up to 3 custom tags
    ];
    
    // Remove duplicates and ensure proper format
    allHashtags = [...new Set(allHashtags)]
      .map(tag => tag.startsWith('#') ? tag : `#${tag}`)
      .slice(0, 15); // Limit to 15 total hashtags
    
    // Generate hashtag string for different platforms
    const hashtagString = formatHashtagsForPlatform(allHashtags, platform);
    
    return {
      hashtags: allHashtags,
      hashtagString,
      breakdown: {
        trending: rotatedTrending,
        niche: rotatedNiche,
        branded: rotatedBranded,
        custom: customTags.slice(0, 3)
      },
      platform,
      category,
      generatedAt: new Date().toISOString(),
      rotationId: generateRotationId()
    };
  } catch (error) {
    console.error('Error generating custom hashtags:', error);
    // Return fallback hashtags
    return {
      hashtags: ['#viral', '#trending', '#AutoPromoteBoosted'],
      hashtagString: '#viral #trending #AutoPromoteBoosted',
      error: error.message
    };
  }
}

/**
 * Rotate hashtags to avoid spam filters
 * @param {string[]} hashtags - Array of hashtags
 * @param {string} cacheKey - Cache key for rotation tracking
 * @param {number} count - Number of hashtags to select
 * @returns {string[]} Rotated hashtags
 */
function rotateHashtags(hashtags, cacheKey, count) {
  if (!hashtags || hashtags.length === 0) return [];
  
  // Get last used hashtags from cache
  const lastUsed = hashtagRotationCache.get(cacheKey) || [];
  
  // Filter out recently used hashtags (avoid using same tags in last 3 rotations)
  const available = hashtags.filter(tag => !lastUsed.includes(tag));
  
  // If not enough available, reset rotation
  const pool = available.length >= count ? available : hashtags;
  
  // Shuffle and select
  const selected = shuffleArray(pool).slice(0, count);
  
  // Update cache (keep last 10 used tags)
  const newCache = [...selected, ...lastUsed].slice(0, 10);
  hashtagRotationCache.set(cacheKey, newCache);
  
  return selected;
}

/**
 * Format hashtags for specific platform
 * @param {string[]} hashtags - Array of hashtags
 * @param {string} platform - Platform name
 * @returns {string} Formatted hashtag string
 */
function formatHashtagsForPlatform(hashtags, platform) {
  switch (platform) {
    case 'tiktok':
    case 'instagram':
      // Space-separated for caption
      return hashtags.join(' ');
    case 'youtube':
      // Comma-separated for tags field
      return hashtags.map(tag => tag.replace('#', '')).join(', ');
    case 'twitter':
      // Space-separated, but limit to 280 chars
      let result = hashtags.join(' ');
      return result.length > 200 ? hashtags.slice(0, 8).join(' ') : result;
    case 'facebook':
      // Space-separated
      return hashtags.join(' ');
    default:
      return hashtags.join(' ');
  }
}

/**
 * Detect content category from title and description
 * @param {object} content - Content object
 * @returns {string} Detected category
 */
function detectCategory(content) {
  const text = `${content.title || ''} ${content.description || ''}`.toLowerCase();
  
  const categoryKeywords = {
    entertainment: ['funny', 'comedy', 'entertainment', 'fun', 'laugh', 'joke', 'meme'],
    lifestyle: ['lifestyle', 'daily', 'vlog', 'life', 'routine', 'day in'],
    beauty: ['beauty', 'makeup', 'skincare', 'cosmetic', 'hair', 'nails'],
    fitness: ['fitness', 'workout', 'gym', 'exercise', 'health', 'training'],
    food: ['food', 'recipe', 'cooking', 'chef', 'meal', 'delicious'],
    tech: ['tech', 'technology', 'gadget', 'review', 'unbox', 'software'],
    gaming: ['gaming', 'game', 'gameplay', 'gamer', 'play', 'video game'],
    music: ['music', 'song', 'sing', 'musician', 'cover', 'beat'],
    education: ['tutorial', 'how to', 'learn', 'teach', 'education', 'guide'],
    business: ['business', 'entrepreneur', 'startup', 'marketing', 'sales']
  };
  
  for (const [category, keywords] of Object.entries(categoryKeywords)) {
    if (keywords.some(keyword => text.includes(keyword))) {
      return category;
    }
  }
  
  return 'general';
}

/**
 * Track hashtag performance for analytics
 * @param {object} params - Tracking parameters
 * @returns {Promise<object>} Tracking result
 */
async function trackHashtagPerformance({ contentId, hashtags, platform, metrics = {} }) {
  try {
    const trackingRef = db.collection('hashtag_performance').doc();
    
    const trackingData = {
      contentId,
      hashtags,
      platform,
      metrics: {
        views: metrics.views || 0,
        engagements: metrics.engagements || 0,
        shares: metrics.shares || 0,
        reach: metrics.reach || 0
      },
      trackedAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    await trackingRef.set(trackingData);
    
    // Update hashtag statistics
    for (const hashtag of hashtags) {
      await updateHashtagStats(hashtag, platform, metrics);
    }
    
    return {
      success: true,
      trackingId: trackingRef.id,
      contentId,
      hashtags,
      platform
    };
  } catch (error) {
    console.error('Error tracking hashtag performance:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Update individual hashtag statistics
 * @param {string} hashtag - Hashtag to update
 * @param {string} platform - Platform name
 * @param {object} metrics - Performance metrics
 */
async function updateHashtagStats(hashtag, platform, metrics) {
  try {
    const statsRef = db.collection('hashtag_stats').doc(`${platform}_${hashtag}`);
    const statsDoc = await statsRef.get();
    
    if (statsDoc.exists) {
      const currentStats = statsDoc.data();
      await statsRef.update({
        totalViews: (currentStats.totalViews || 0) + (metrics.views || 0),
        totalEngagements: (currentStats.totalEngagements || 0) + (metrics.engagements || 0),
        totalShares: (currentStats.totalShares || 0) + (metrics.shares || 0),
        usageCount: (currentStats.usageCount || 0) + 1,
        lastUsed: new Date().toISOString(),
        avgViews: ((currentStats.totalViews || 0) + (metrics.views || 0)) / ((currentStats.usageCount || 0) + 1),
        avgEngagements: ((currentStats.totalEngagements || 0) + (metrics.engagements || 0)) / ((currentStats.usageCount || 0) + 1)
      });
    } else {
      await statsRef.set({
        hashtag,
        platform,
        totalViews: metrics.views || 0,
        totalEngagements: metrics.engagements || 0,
        totalShares: metrics.shares || 0,
        usageCount: 1,
        firstUsed: new Date().toISOString(),
        lastUsed: new Date().toISOString(),
        avgViews: metrics.views || 0,
        avgEngagements: metrics.engagements || 0
      });
    }
  } catch (error) {
    console.error('Error updating hashtag stats:', error);
  }
}

/**
 * Get top performing hashtags for a platform
 * @param {string} platform - Platform name
 * @param {number} limit - Number of hashtags to return
 * @returns {Promise<object[]>} Top performing hashtags
 */
async function getTopPerformingHashtags(platform, limit = 20) {
  try {
    const statsSnapshot = await db.collection('hashtag_stats')
      .where('platform', '==', platform)
      .orderBy('avgViews', 'desc')
      .limit(limit)
      .get();
    
    const topHashtags = [];
    statsSnapshot.forEach(doc => {
      topHashtags.push({ id: doc.id, ...doc.data() });
    });
    
    return topHashtags;
  } catch (error) {
    console.error('Error getting top performing hashtags:', error);
    return [];
  }
}

/**
 * Get branded hashtag community for platform
 * @param {string} platform - Platform name
 * @returns {string[]} Community hashtags
 */
function getBrandedHashtagCommunity(platform) {
  return [
    ...BRANDED_HASHTAGS.community,
    ...(BRANDED_HASHTAGS.platform[platform] || []),
    ...BRANDED_HASHTAGS.core.slice(0, 2)
  ];
}

/**
 * Shuffle array using Fisher-Yates algorithm
 * @param {Array} array - Array to shuffle
 * @returns {Array} Shuffled array
 */
function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Generate unique rotation ID
 * @returns {string} Rotation ID
 */
function generateRotationId() {
  return `rot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

module.exports = {
  generateCustomHashtags,
  getTrendingHashtags,
  getNicheHashtags,
  getBrandedHashtags,
  trackHashtagPerformance,
  getTopPerformingHashtags,
  getBrandedHashtagCommunity,
  formatHashtagsForPlatform,
  detectCategory
};
